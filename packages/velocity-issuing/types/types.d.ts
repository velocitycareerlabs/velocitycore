export interface CredentialMetadata extends AllocationListEntry {
  contentHash: string;
  credentialType: string;
  credentialTypeByteEncoding: string;
  publicKey: string;
}

export interface DbKey {
  privateKey: string;
  kidFragment: string;
}

export interface AllocationListQueries {
  allocateNextEntry: (
    entityName: string,
    issuer: Issuer
  ) => AllocationListEntry;
  createNewAllocationList: (
    entityName: string,
    issuer: Issuer,
    newListId: number,
    allocations: number[]
  ) => AllocationListEntry;
}

// TODO add support for signing transactions and jwts without keys leaving the KMS sandbox
/**
 * Loads keys and in the future signs transactions or JWTs
 */
export interface KMS {
  loadKey: (keyId: string) => DbKey;
  // signJwt: (jwtJson: object, keyId: string) => string
  // signTransaction: (transaction: string, keyId: string) => string
}

export interface Context {
  // contracts
  /**
   * Config for the nominated CAO whos creds need to be used for DLT node calls.
   * TODO make this id & credentials instead OR make the contract services injection much smarter
   */
  caoDid: string;
  /**
   * config object containing the contract addresses for the chain.
   * TODO tighten up type safety
   */
  config: object;
  /**
   * A RPC provider.
   * TODO explore removing
   */
  rpcProvider?: unknown;
  // db
  /**
   * The db connection object.
   */
  allocationListQueries: AllocationListQueries;
  // credentialTypes
  /**
   * a registrar fetcher for loading credential types.
   * TODO explore having credential types as a dependency and remvoing fetcher and cache
   */
  registrarFetch: unknown;
  /**
   * a cache for fetch results
   */
  cache?: unknown;
  // key signing
  /**
   * A KMS interface for loading keys.
   *
   */
  kms: KMS;
}

export interface Entity {
  id: string;
  did: string;
  dltOperatorAddress: string;
  dltOperatorKMSKeyId: string;
  issuingServiceDIDKeyId: string;
  dltPrimaryAddress: string;
}

export interface Issuer extends Entity {
  issuingServiceId: string;
  issuingServiceKMSKeyId: string;
  issuingServiceDIDKeyId: string;
}

/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface CredentialTypeMetadata {
  id: string;
  credentialType: string;
  layer1: boolean;
  jsonldContext: string[];
  schemaUrl: string;
}

export interface BaseCredential {
  /**
   * json-ld context
   */
  '@context'?: string | string[];
  /**
   * type is identical to the standard based type found on verifiable credentials but does not accept a plane string,
   * it only accepts an array to indicate an unordered set of type URIs
   */
  type: string[];
  /**
   * when the credential will start being valid
   */
  validFrom?: string;
  /**
   * when the credential will expire
   */
  validUntil?: string;
  replaces?: NewResourceReference[];
  relatedResource?: NewResourceReference[];
}

/**
 * A DLT list entry is used for managing entries on dlt lists
 */
export interface AllocationListEntry {
  isNewList: boolean;
  listId: number;
  index: number;
}

export interface VelocityOffer extends BaseCredential {
  /**
   * Contains all the claims of the credential
   */
  credentialSubject: {
    [k: string]: unknown;
  };
  /**
   * issuer to include if using branding for the issuer
   */
  issuer: {
    id: string;
    name?: string;
    image?: string;
  };
  [k: string]: unknown;
}

export interface JsonLdCredential extends BaseCredential {
  /**
   * id of the credential
   */
  id: string;
  /**
   * Contains all the claims of the credential
   */
  credentialSubject: CredentialSubject;
  /**
   * issuer is either a DID or an object containig DID and optional branding information
   */
  issuer:
    | string
    | {
        id: string;
        type?: string | string[];
        name?: string;
        image?: string;
      };
  issued: string;
  /**
   * content hash of the offer
   */
  contentHash: {
    type: string;
    value: string;
  };
  refreshService?: LinkedData | LinkedData[];
  credentialSchema?: LinkedData | LinkedData[];
  vnfProtocolVersion: string;
  [k: string]: unknown;
}

export interface CredentialSubject {
  /**
   * json-ld context
   */
  '@context': string | string[];
  /**
   * type is identical to the standard based type found on verifiable credentials but does not accept a plane string,
   * it only accepts an array to indicate an unordered set of type URIs
   */
  type: string | string[];
  /**
   * Optional id property identifies the credential subject
   */
  id?: string;
  [k: string]: unknown;
}

export type ResourceReference = {
  /**
   * the id of the resource that is an alternative
   */
  id: string;
  /**
   * the type of alternative. PDF or VC
   */
  type?: string | string[];
  /**
   * the media type of the URI. Can be used to validate what is download  ed
   */
  mediaType?: string;
  /**
   * the digest of the object
   */
  digestSRI?: string;
  /**
   * the name of the referenced resource
   */
  name?: string;
  /**
   * rendering hints for wallets. Can be used to validate the downloaded credential
   */
  hint?: string | string[];
};

export type NewResourceReference =
  | ResourceReference
  | {
      /**
       * a reference to an offerId in the same exchange
       */
      offerId: string;
      /**
       * the type of alternative. PDF or VC
       */
      type?: string | string[];
    };

/**
 * A linked data reference in JSON-LD.
 */
export interface LinkedData {
  id: string;
  type?: string | string[];
}
